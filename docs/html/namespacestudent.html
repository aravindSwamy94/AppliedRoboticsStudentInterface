<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Robot Planning and its Applications Project: student Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Planning and its Applications Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">student Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab3f1d6c8dd4caa817efc0cd3c46eb2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab3f1d6c8dd4caa817efc0cd3c46eb2e0">mouseCallback</a> (int event, int x, int y, int, void *p)</td></tr>
<tr class="memdesc:ab3f1d6c8dd4caa817efc0cd3c46eb2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after every mouse click.  <a href="#ab3f1d6c8dd4caa817efc0cd3c46eb2e0">More...</a><br /></td></tr>
<tr class="separator:ab3f1d6c8dd4caa817efc0cd3c46eb2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01244e0e0a28d974de100ffcad7a2583"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point2f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a01244e0e0a28d974de100ffcad7a2583">pickNPoints</a> (int n0, const cv::Mat &amp;img)</td></tr>
<tr class="memdesc:a01244e0e0a28d974de100ffcad7a2583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to pick points from image.  <a href="#a01244e0e0a28d974de100ffcad7a2583">More...</a><br /></td></tr>
<tr class="separator:a01244e0e0a28d974de100ffcad7a2583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6103f938ce28f8820c48c089d5f95098"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a6103f938ce28f8820c48c089d5f95098">extrinsicCalib</a> (const cv::Mat &amp;img_in, std::vector&lt; cv::Point3f &gt; object_points, const cv::Mat &amp;camera_matrix, cv::Mat &amp;rvec, cv::Mat &amp;tvec, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:a6103f938ce28f8820c48c089d5f95098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for extrinsic calibration.  <a href="#a6103f938ce28f8820c48c089d5f95098">More...</a><br /></td></tr>
<tr class="separator:a6103f938ce28f8820c48c089d5f95098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb2a29362b8223a9d3601d9496e1c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aceb2a29362b8223a9d3601d9496e1c98">imageUndistort</a> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;cam_matrix, const cv::Mat &amp;dist_coeffs, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:aceb2a29362b8223a9d3601d9496e1c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function undistort the given image.  <a href="#aceb2a29362b8223a9d3601d9496e1c98">More...</a><br /></td></tr>
<tr class="separator:aceb2a29362b8223a9d3601d9496e1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528d33658d0d4d982a46f18b7abb4a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a528d33658d0d4d982a46f18b7abb4a70">findPlaneTransform</a> (const cv::Mat &amp;cam_matrix, const cv::Mat &amp;rvec, const cv::Mat &amp;tvec, const std::vector&lt; cv::Point3f &gt; &amp;object_points_plane, const std::vector&lt; cv::Point2f &gt; &amp;dest_image_points_plane, cv::Mat &amp;plane_transf, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:a528d33658d0d4d982a46f18b7abb4a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perspective projection.  <a href="#a528d33658d0d4d982a46f18b7abb4a70">More...</a><br /></td></tr>
<tr class="separator:a528d33658d0d4d982a46f18b7abb4a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8caf348979f55e58a75193233c219d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a6b8caf348979f55e58a75193233c219d">unwarp</a> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;transf, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:a6b8caf348979f55e58a75193233c219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image unwarping.  <a href="#a6b8caf348979f55e58a75193233c219d">More...</a><br /></td></tr>
<tr class="separator:a6b8caf348979f55e58a75193233c219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd56b779672a672e15ac45dc927b8a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#afd56b779672a672e15ac45dc927b8a6b">findRobot</a> (const cv::Mat &amp;img_in, const double scale, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;triangle, double &amp;x, double &amp;y, double &amp;theta, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:afd56b779672a672e15ac45dc927b8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find Robot function in student interface  <a href="#afd56b779672a672e15ac45dc927b8a6b">More...</a><br /></td></tr>
<tr class="separator:afd56b779672a672e15ac45dc927b8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3117c968a47bf95f86bdb813a3b64e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a3117c968a47bf95f86bdb813a3b64e56">loadImage</a> (cv::Mat &amp;img_out, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:a3117c968a47bf95f86bdb813a3b64e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">load Image function in student interface  <a href="#a3117c968a47bf95f86bdb813a3b64e56">More...</a><br /></td></tr>
<tr class="separator:a3117c968a47bf95f86bdb813a3b64e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f4da9abe090023fe1fbf23f75b5b42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a38f4da9abe090023fe1fbf23f75b5b42">getCurvature</a> (int step, <a class="el" href="structPath.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a38f4da9abe090023fe1fbf23f75b5b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf207b6433d914c39067b7d538c2956c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#abf207b6433d914c39067b7d538c2956c">sort_pair_mission2</a> (const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;a, const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;b)</td></tr>
<tr class="separator:abf207b6433d914c39067b7d538c2956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962ac10ed4e3bf5be63aad206b4fc624"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a962ac10ed4e3bf5be63aad206b4fc624">obstacleOffsetting</a> (const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; ob, int offset_radius)</td></tr>
<tr class="memdesc:a962ac10ed4e3bf5be63aad206b4fc624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand obstacles region to avoid collision.  <a href="#a962ac10ed4e3bf5be63aad206b4fc624">More...</a><br /></td></tr>
<tr class="separator:a962ac10ed4e3bf5be63aad206b4fc624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4533d2b12567821a0dbb957d0e607fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a4533d2b12567821a0dbb957d0e607fc0">resizeBorders</a> (const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;borders, int resize)</td></tr>
<tr class="memdesc:a4533d2b12567821a0dbb957d0e607fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the border for avoiding collision with border.  <a href="#a4533d2b12567821a0dbb957d0e607fc0">More...</a><br /></td></tr>
<tr class="separator:a4533d2b12567821a0dbb957d0e607fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7520b9efd4309e03ec51e8cd7642b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#acf7520b9efd4309e03ec51e8cd7642b0">sample_borders</a> (<a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;borders)</td></tr>
<tr class="memdesc:acf7520b9efd4309e03ec51e8cd7642b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the borders with multiple points.  <a href="#acf7520b9efd4309e03ec51e8cd7642b0">More...</a><br /></td></tr>
<tr class="separator:acf7520b9efd4309e03ec51e8cd7642b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9329b042a3a7854a08219559fb863"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a4bc9329b042a3a7854a08219559fb863">get_center</a> (const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;poly)</td></tr>
<tr class="memdesc:a4bc9329b042a3a7854a08219559fb863"><td class="mdescLeft">&#160;</td><td class="mdescRight">get centroid of any polygon  <a href="#a4bc9329b042a3a7854a08219559fb863">More...</a><br /></td></tr>
<tr class="separator:a4bc9329b042a3a7854a08219559fb863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c112c915d7bf1e28084673499b7d5ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a9c112c915d7bf1e28084673499b7d5ef">pointInsidePolygon</a> (<a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> poly, <a class="el" href="structPoint.html">Point</a> pt)</td></tr>
<tr class="memdesc:a9c112c915d7bf1e28084673499b7d5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check if a given point is inside polygon  <a href="#a9c112c915d7bf1e28084673499b7d5ef">More...</a><br /></td></tr>
<tr class="separator:a9c112c915d7bf1e28084673499b7d5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da434a66dc725fa325433bb9bd4e989"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a2da434a66dc725fa325433bb9bd4e989">compute_angle_gate</a> (<a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> borders, double gateX, double gateY)</td></tr>
<tr class="memdesc:a2da434a66dc725fa325433bb9bd4e989"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to compute the gate angle  <a href="#a2da434a66dc725fa325433bb9bd4e989">More...</a><br /></td></tr>
<tr class="separator:a2da434a66dc725fa325433bb9bd4e989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e0adb0fb2cb218e2410c460af2cae7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac8e0adb0fb2cb218e2410c460af2cae7">internal_angle</a> (double angle1, double angle2)</td></tr>
<tr class="separator:ac8e0adb0fb2cb218e2410c460af2cae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51402ca51fa6c279f88cf560e32b422"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac51402ca51fa6c279f88cf560e32b422">get_angle</a> (<a class="el" href="structPose.html">Pose</a> first, <a class="el" href="structPose.html">Pose</a> second, <a class="el" href="structPose.html">Pose</a> third)</td></tr>
<tr class="memdesc:ac51402ca51fa6c279f88cf560e32b422"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to compute the approach angle between two nodes  <a href="#ac51402ca51fa6c279f88cf560e32b422">More...</a><br /></td></tr>
<tr class="separator:ac51402ca51fa6c279f88cf560e32b422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e23765e95f85572437c4f8bc2bc6d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7e23765e95f85572437c4f8bc2bc6d6e">check_collison_with_borders_and_obstacles</a> (<a class="el" href="structPath.html">Path</a> path, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> borders, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> sampled_borders, std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; obstacle_list, std::vector&lt; double &gt; obs_radius, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; obs_center)</td></tr>
<tr class="memdesc:a7e23765e95f85572437c4f8bc2bc6d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check if the generated path is colliding with borders and obstacles  <a href="#a7e23765e95f85572437c4f8bc2bc6d6e">More...</a><br /></td></tr>
<tr class="separator:a7e23765e95f85572437c4f8bc2bc6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae985c265d91c51e3afdc782c70964ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae985c265d91c51e3afdc782c70964ecd">RRT_Star</a> (const float x, const float y, const float theta, <a class="el" href="structPath.html">Path</a> &amp;path, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;localGoals, const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;borders, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;sampled_borders, const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;obstacle_list, std::vector&lt; double &gt; obs_radius, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; obs_center, <a class="el" href="classconfig__Params__planPath.html">config_Params_planPath</a> config_params)</td></tr>
<tr class="memdesc:ae985c265d91c51e3afdc782c70964ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">implmentation of RRT Star function  <a href="#ae985c265d91c51e3afdc782c70964ecd">More...</a><br /></td></tr>
<tr class="separator:ae985c265d91c51e3afdc782c70964ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f6c07df2df619bef2b28d6f7ebcac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab8f6c07df2df619bef2b28d6f7ebcac7">RRT_Star_ompl</a> (const float x, const float y, const float theta, <a class="el" href="structPath.html">Path</a> &amp;path, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;localGoals, const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;borders, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;sampled_borders, const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;obstacle_list, std::vector&lt; double &gt; obs_radius, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; obs_center, <a class="el" href="classconfig__Params__planPath.html">config_Params_planPath</a> config_params)</td></tr>
<tr class="memdesc:ab8f6c07df2df619bef2b28d6f7ebcac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">implmentation of RRT Star function using OMPL library  <a href="#ab8f6c07df2df619bef2b28d6f7ebcac7">More...</a><br /></td></tr>
<tr class="separator:ab8f6c07df2df619bef2b28d6f7ebcac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d911d7d7118f5393eeb575e0e76cdf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a6d911d7d7118f5393eeb575e0e76cdf6">compute_vicitim_mission2</a> (const float x, const float y, const float theta, const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;borders, const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;obstacle_list, std::pair&lt; double, double &gt; gateCenter, std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; victim_list, <a class="el" href="classconfig__Params__planPath.html">config_Params_planPath</a> config_params)</td></tr>
<tr class="memdesc:a6d911d7d7118f5393eeb575e0e76cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">implmentation of Mission targets for mision 2  <a href="#a6d911d7d7118f5393eeb575e0e76cdf6">More...</a><br /></td></tr>
<tr class="separator:a6d911d7d7118f5393eeb575e0e76cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe62076a49d23bb083f2f880fd24c77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#acfe62076a49d23bb083f2f880fd24c77">planPath</a> (const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;borders, const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;obstacle_list, const std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; &amp;victim_list, const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;gate, const float x, const float y, const float theta, <a class="el" href="structPath.html">Path</a> &amp;path, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:acfe62076a49d23bb083f2f880fd24c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plan a safe and fast path in the arena.  <a href="#acfe62076a49d23bb083f2f880fd24c77">More...</a><br /></td></tr>
<tr class="separator:acfe62076a49d23bb083f2f880fd24c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae5c8a6b753e8c2f86e2a6f70c44faf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a5ae5c8a6b753e8c2f86e2a6f70c44faf">sort_pair</a> (const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;a, const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;b)</td></tr>
<tr class="separator:a5ae5c8a6b753e8c2f86e2a6f70c44faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b392b6e41e30b0e80eadf53d6d890b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a18b392b6e41e30b0e80eadf53d6d890b">processObstacles</a> (const cv::Mat &amp;hsv_img, const double scale, std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;obstacle_list, <a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a> config_params)</td></tr>
<tr class="memdesc:a18b392b6e41e30b0e80eadf53d6d890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obstacle detection function.  <a href="#a18b392b6e41e30b0e80eadf53d6d890b">More...</a><br /></td></tr>
<tr class="separator:a18b392b6e41e30b0e80eadf53d6d890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb444a179b51148e9ad476a016f8fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#abfb444a179b51148e9ad476a016f8fe3">processGate</a> (const cv::Mat &amp;hsv_img, const double scale, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;gate, <a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a> config_params)</td></tr>
<tr class="memdesc:abfb444a179b51148e9ad476a016f8fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">gate detection function  <a href="#abfb444a179b51148e9ad476a016f8fe3">More...</a><br /></td></tr>
<tr class="separator:abfb444a179b51148e9ad476a016f8fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d19daafa227fb7503f8ff4111243d4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a4d19daafa227fb7503f8ff4111243d4d">get_victim_id</a> (cv::Rect boundingRect, cv::Mat img, <a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a> config_params)</td></tr>
<tr class="memdesc:a4d19daafa227fb7503f8ff4111243d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get victim ID.  <a href="#a4d19daafa227fb7503f8ff4111243d4d">More...</a><br /></td></tr>
<tr class="separator:a4d19daafa227fb7503f8ff4111243d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd3cda22103f4e0c2ddb32cc68789c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a6dd3cda22103f4e0c2ddb32cc68789c7">processVictims</a> (const cv::Mat &amp;hsv_img, const double scale, std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; &amp;victim_list, <a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a> config_params)</td></tr>
<tr class="memdesc:a6dd3cda22103f4e0c2ddb32cc68789c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Victim detection function along with digit recognition call.  <a href="#a6dd3cda22103f4e0c2ddb32cc68789c7">More...</a><br /></td></tr>
<tr class="separator:a6dd3cda22103f4e0c2ddb32cc68789c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a17ef667d7c10b8f33d815b9bc1bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a153a17ef667d7c10b8f33d815b9bc1bc">processMap</a> (const cv::Mat &amp;img_in, const double scale, std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;obstacle_list, std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; &amp;victim_list, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;gate, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:a153a17ef667d7c10b8f33d815b9bc1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to call processObstacles, processGate and processVictims.  <a href="#a153a17ef667d7c10b8f33d815b9bc1bc">More...</a><br /></td></tr>
<tr class="separator:a153a17ef667d7c10b8f33d815b9bc1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b726e7af03a643c06dcde23057a82ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a3b726e7af03a643c06dcde23057a82ea">genericImageListener</a> (const cv::Mat &amp;img_in, std::string topic, const std::string &amp;config_folder)</td></tr>
<tr class="memdesc:a3b726e7af03a643c06dcde23057a82ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to save images for intrinsic calibration.  <a href="#a3b726e7af03a643c06dcde23057a82ea">More...</a><br /></td></tr>
<tr class="separator:a3b726e7af03a643c06dcde23057a82ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a65fee22a07178fcde6362c2482b5fa7f"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a65fee22a07178fcde6362c2482b5fa7f">dist_coeffs_for_ex</a></td></tr>
<tr class="separator:a65fee22a07178fcde6362c2482b5fa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba626c3c54f4003c9c06f7fea899efc2"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aba626c3c54f4003c9c06f7fea899efc2">debug_image</a></td></tr>
<tr class="separator:aba626c3c54f4003c9c06f7fea899efc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7e23765e95f85572437c4f8bc2bc6d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::check_collison_with_borders_and_obstacles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPath.html">Path</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&#160;</td>
          <td class="paramname"><em>sampled_borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>obs_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>obs_center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to check if the generated path is colliding with borders and obstacles </p>
<p>This is an additional function which checcks if the path generated by Clothoids/Dubins is colliding with the obstacles and borders. Here sampled borders are used to check the distance between path and borders </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path generated by Clothoids/Dubins </td></tr>
    <tr><td class="paramname">sampled_borders</td><td>the borders points which are sampled </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>The list of obstacle and their points </td></tr>
    <tr><td class="paramname">obs_radius</td><td>Radius of each obstacle </td></tr>
    <tr><td class="paramname">obs_center</td><td>Center of each obstacle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false- Colliding/Not Colliding </dd></dl>

</div>
</div>
<a class="anchor" id="a2da434a66dc725fa325433bb9bd4e989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double student::compute_angle_gate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gateX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gateY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to compute the gate angle </p>
<p>gate angle is very important and cannot be same as other cases. Because the recatngle of gate can be different locations(Left,Right,Bottom,Top) and oriented(Horizontal, Vertical) in different way. A combination of the locations and orientation are possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>the border locations </td></tr>
    <tr><td class="paramname">gateX</td><td>gate center X </td></tr>
    <tr><td class="paramname">gateY</td><td>gate center Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the approach angle of the final gate </dd></dl>

</div>
</div>
<a class="anchor" id="a6d911d7d7118f5393eeb575e0e76cdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structPoint.html">Point</a>&gt; student::compute_vicitim_mission2 </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; double, double &gt;&#160;</td>
          <td class="paramname"><em>gateCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__planPath.html">config_Params_planPath</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implmentation of Mission targets for mision 2 </p>
<p>This is very simple logic, where RRT* path is generated from source and gate . And a threshold value is used to check the distance of victims from path. If the distance is high the cost is computed accordingly and that vicitm is rejected to be saved. Also the victim is then sorted based on their occurance in path direction. This helps save time for robot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The robot location x </td></tr>
    <tr><td class="paramname">y</td><td>The robot location y </td></tr>
    <tr><td class="paramname">theta</td><td>The robot orientation theta </td></tr>
    <tr><td class="paramname">path</td><td>the output path variable </td></tr>
    <tr><td class="paramname">localGoals</td><td>the local goals which includes the victims and gate </td></tr>
    <tr><td class="paramname">borders</td><td>original borders </td></tr>
    <tr><td class="paramname">sampled_borders</td><td>the borders points which are sampled </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>The list of obstacle and their points </td></tr>
    <tr><td class="paramname">obs_radius</td><td>Radius of each obstacle </td></tr>
    <tr><td class="paramname">obs_center</td><td>Center of each obstacle </td></tr>
    <tr><td class="paramname">config_folder</td><td>Config folder which contains config file to get parameters realted to RRT* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6103f938ce28f8820c48c089d5f95098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::extrinsicCalib </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point3f &gt;&#160;</td>
          <td class="paramname"><em>object_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for extrinsic calibration. </p>
<p>Extrinsic calibration to determine the Rotational and translational matrix. Four points will be chosen in the image plane and then these 4 points will be solved using the solvePnP interface from opencv to solve the extrinsic problem. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>input image </td></tr>
    <tr><td class="paramname">oject_points</td><td>4 points that are chosen in image </td></tr>
    <tr><td class="paramname">camera_matrix</td><td>The obtained camera matrix from intrinsic calibration </td></tr>
    <tr><td class="paramname">rvec</td><td>Output rotational vector </td></tr>
    <tr><td class="paramname">tvec</td><td>Output translational vector </td></tr>
    <tr><td class="paramname">config_folder</td><td>Output folder (if file existing then function justs reads the file to get rvec and tvec) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a528d33658d0d4d982a46f18b7abb4a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::findPlaneTransform </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cam_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_points_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest_image_points_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>plane_transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perspective projection. </p>
<p>Now to have a bird’s eye view of the image, where we need to project the 3D objects in a image plane, carry out Perspective Projection initially. This is again carried out with the opencv interfaces, projectPoints() and getPerspectiveTransform(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cam_matrix</td><td>camera_matrix </td></tr>
    <tr><td class="paramname">rvec</td><td>Output rotational vector </td></tr>
    <tr><td class="paramname">tvec</td><td>Output translational vector </td></tr>
    <tr><td class="paramname">object_points_plane</td><td>Object points </td></tr>
    <tr><td class="paramname">dest_image_points_plane</td><td>destination image points plane </td></tr>
    <tr><td class="paramname">config_folder</td><td>Output folder (if file existing then function justs reads the file to get rvec and tvec) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd56b779672a672e15ac45dc927b8a6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::findRobot </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find Robot function in student interface </p>
<p>Directly utilized the function provided by the teaching assistant as I found that implementation was already in the best shape. RGB→HSV→blue mask→Contours→Approximate polynomial→find 3 points of polynomial→Find center of triangle→Find angle between top vertex and center(Orientation)→return state(x,y,ψ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input Image </td></tr>
    <tr><td class="paramname">scale</td><td>scaling factor </td></tr>
    <tr><td class="paramname">triangle</td><td>The outpu triangle of robot </td></tr>
    <tr><td class="paramname">x</td><td>robot pose (center) x </td></tr>
    <tr><td class="paramname">y</td><td>robot pose (center) y </td></tr>
    <tr><td class="paramname">theta</td><td>robot pose (initial) theta </td></tr>
    <tr><td class="paramname">config_folder</td><td>config folder if any configuration params to be loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false robot found or not </dd></dl>

</div>
</div>
<a class="anchor" id="a3b726e7af03a643c06dcde23057a82ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::genericImageListener </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to save images for intrinsic calibration. </p>
<p>Through this the images are saved from the simulator which contains checkerboard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input Image </td></tr>
    <tr><td class="paramname">topic</td><td>topic in which the image arrives </td></tr>
    <tr><td class="paramname">config_folder</td><td>config folder to store the saved images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false robot found or not </dd></dl>

</div>
</div>
<a class="anchor" id="ac51402ca51fa6c279f88cf560e32b422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double student::get_angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPose.html">Pose</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPose.html">Pose</a>&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPose.html">Pose</a>&#160;</td>
          <td class="paramname"><em>third</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to compute the approach angle between two nodes </p>
<p>The motion planning generates points betwwen source, victims and to gate. This points are then given to local planner(Clothoids/Dubins). This function will compute the approach angle between two points. Also a special logic to get the approach angle for victims. The logic is to use the line segment angle difference. Three points are taken, the angle between the first line segment(first and second points) and next line segments(second and third points) are used to compute thh approach angle of second point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First point </td></tr>
    <tr><td class="paramname">second</td><td>Second point </td></tr>
    <tr><td class="paramname">third</td><td>Third point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the approach angle of the second point </dd></dl>

</div>
</div>
<a class="anchor" id="a4bc9329b042a3a7854a08219559fb863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;double, double&gt; student::get_center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get centroid of any polygon </p>
<p>sum_of_all_vertices/ size_of_vertices </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>Inpput polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>center as a std::pair </dd></dl>

</div>
</div>
<a class="anchor" id="a4d19daafa227fb7503f8ff4111243d4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int student::get_victim_id </td>
          <td>(</td>
          <td class="paramtype">cv::Rect&#160;</td>
          <td class="paramname"><em>boundingRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get victim ID. </p>
<p>This is mainly done to detect the number of Victims, so that the priority to save the victims can be known to the planning algorithm. This involves template matching majorly and the templates were provided in lecture. I have used majorly the opencv template matching methods. But I also implemented the tesseract-ocr method,although the results were not satisfying. Template rotation was performed ,Each template will be rotated by 5 degrees and then they are set to calculate the score and the maximum of all of that will be be finalized as digits. Steps followed: Detect Victims→get bounding rect→mask and filter image→change background→read templates→Resize and filter the ROI→change different orientation of ROI→match template→return Digit </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundingRect</td><td>The bounding rectangle of the victim location </td></tr>
    <tr><td class="paramname">img</td><td>hsv image of the input </td></tr>
    <tr><td class="paramname">config_params</td><td>configuration parameters realted to obstacle detection, includes template location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vicitm id </dd></dl>

</div>
</div>
<a class="anchor" id="a38f4da9abe090023fe1fbf23f75b5b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::getCurvature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aceb2a29362b8223a9d3601d9496e1c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::imageUndistort </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cam_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dist_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function undistort the given image. </p>
<p>Using the distortion coefficients obtained in the previous steps, remove the distorted effect on the image. This is done using the opencv undistort function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>input image </td></tr>
    <tr><td class="paramname">img_out</td><td>output image </td></tr>
    <tr><td class="paramname">camera_matrix</td><td>The obtained camera matrix from intrinsic calibration </td></tr>
    <tr><td class="paramname">dist_coeffs</td><td>distortion coefficients </td></tr>
    <tr><td class="paramname">config_folder</td><td>Output folder (if file existing then function justs reads the file to get rvec and tvec) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8e0adb0fb2cb218e2410c460af2cae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double student::internal_angle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3117c968a47bf95f86bdb813a3b64e56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::loadImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load Image function in student interface </p>
<p>Function used directly given by Teaching assistant </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_out</td><td>Output Image </td></tr>
    <tr><td class="paramname">config_folder</td><td>location where load image is stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3f1d6c8dd4caa817efc0cd3c46eb2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::mouseCallback </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function called after every mouse click. </p>
<p>Function obatined from Professor interface </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>mouse event occured </td></tr>
    <tr><td class="paramname">x</td><td>x-position of mouse event </td></tr>
    <tr><td class="paramname">y</td><td>y-position of mouse event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a962ac10ed4e3bf5be63aad206b4fc624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&gt; student::obstacleOffsetting </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand obstacles region to avoid collision. </p>
<p>Using clipper libray , the execution of enlarging the obstacles is easier with AddPath() and Execute () API's </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>All Obstacles polygon to be expanded </td></tr>
    <tr><td class="paramname">offet_radius</td><td>The radius by which the obstacle is to be expanded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exapanded obstacles with the given radius </dd></dl>

</div>
</div>
<a class="anchor" id="a01244e0e0a28d974de100ffcad7a2583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point2f&gt; student::pickNPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to pick points from image. </p>
<p>Function obatined from Professor interface </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n0</td><td>number of points to be picked </td></tr>
    <tr><td class="paramname">img</td><td>the image from which the points are to be chosen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfe62076a49d23bb083f2f880fd24c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::planPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plan a safe and fast path in the arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>border of the arena [m] </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>list of obstacle polygon [m] </td></tr>
    <tr><td class="paramname">victim_list</td><td>list of pair victim_id and polygon [m] </td></tr>
    <tr><td class="paramname">gate</td><td>polygon representing the gate [m] </td></tr>
    <tr><td class="paramname">x</td><td>x position of the robot in the arena reference system </td></tr>
    <tr><td class="paramname">y</td><td>y position of the robot in the arena reference system </td></tr>
    <tr><td class="paramname">theta</td><td>yaw of the robot in the arena reference system </td></tr>
    <tr><td class="paramname">config_folder</td><td>A custom string from config file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c112c915d7bf1e28084673499b7d5ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::pointInsidePolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPoint.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to check if a given point is inside polygon </p>
<p>using boost::within library </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>input polygon </td></tr>
    <tr><td class="paramname">pt</td><td>input point to check if this is inside the poly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false - insidePolygon/NotInsidePolygon </dd></dl>

</div>
</div>
<a class="anchor" id="abfb444a179b51148e9ad476a016f8fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::processGate </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hsv_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gate detection function </p>
<p>Steps followed: RGB→HSV→Apply Green mask→Contours→approximate Polynomial→detect 4 points→Return Gate </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hsv_img</td><td>HSV Image input </td></tr>
    <tr><td class="paramname">scale</td><td>scaling factor </td></tr>
    <tr><td class="paramname">gate</td><td>Output gate polygon </td></tr>
    <tr><td class="paramname">config_params</td><td>configuration parameters realted to gate detection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false Execution successful </dd></dl>

</div>
</div>
<a class="anchor" id="a153a17ef667d7c10b8f33d815b9bc1bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::processMap </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to call processObstacles, processGate and processVictims. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundingRect</td><td>The bounding rectangle of the victim location </td></tr>
    <tr><td class="paramname">img_in</td><td>rgb image of the input </td></tr>
    <tr><td class="paramname">scale</td><td>scaling factor </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>Output obstacle list </td></tr>
    <tr><td class="paramname">victim_list</td><td>Output victim list pair </td></tr>
    <tr><td class="paramname">gate</td><td>Output gate polygon </td></tr>
    <tr><td class="paramname">config_folder</td><td>config folder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false Execution successful </dd></dl>

</div>
</div>
<a class="anchor" id="a18b392b6e41e30b0e80eadf53d6d890b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::processObstacles </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hsv_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obstacle detection function. </p>
<p>Steps followed RGB→HSV→Apply red mask→Contours→approximate Polynomial→Return Obstacles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hsv_img</td><td>HSV Image input </td></tr>
    <tr><td class="paramname">scale</td><td>Scaling factor </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>Output obstacle list </td></tr>
    <tr><td class="paramname">config_params</td><td>configuration parameters realted to obstacle detection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false Execution successful </dd></dl>
<p>Steps involved in process Obstacles one by one</p>
<p>First range of red region in HSV</p>
<p>Second range of red region in HSV</p>
<p>add the regions of red space in HSV format</p>
<p>find all contours in the image</p>
<p>approximate the contours</p>
<p>create a obstacle list</p>
<p>debug plot in seperate debug image </p>

</div>
</div>
<a class="anchor" id="a6dd3cda22103f4e0c2ddb32cc68789c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::processVictims </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hsv_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__ProcessMap.html">config_Params_ProcessMap</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Victim detection function along with digit recognition call. </p>
<p>Steps followed: RGB→HSV→Apply Green mask→Contours→approximate Polynomial→detect more than 6 points(check circle)→ get id of victim → return Victims </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hsv_img</td><td>HSV Image input </td></tr>
    <tr><td class="paramname">scale</td><td>scaling factor </td></tr>
    <tr><td class="paramname">victim_list</td><td>Output victim list pair </td></tr>
    <tr><td class="paramname">config_params</td><td>configuration parameters realted to gate detection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false Execution successful </dd></dl>

</div>
</div>
<a class="anchor" id="a4533d2b12567821a0dbb957d0e607fc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> student::resizeBorders </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the border for avoiding collision with border. </p>
<p>manual computation of resizing borders </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>border which is given as polygon </td></tr>
    <tr><td class="paramname">resize</td><td>the resizing factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resized border </dd></dl>

</div>
</div>
<a class="anchor" id="ae985c265d91c51e3afdc782c70964ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::RRT_Star </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>localGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>sampled_borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>obs_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>obs_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__planPath.html">config_Params_planPath</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implmentation of RRT Star function </p>
<p>This is an own implementation of RRT Star with few references. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The robot location x </td></tr>
    <tr><td class="paramname">y</td><td>The robot location y </td></tr>
    <tr><td class="paramname">theta</td><td>The robot orientation theta </td></tr>
    <tr><td class="paramname">path</td><td>the output path variable </td></tr>
    <tr><td class="paramname">localGoals</td><td>the local goals which includes the victims and gate </td></tr>
    <tr><td class="paramname">borders</td><td>original borders </td></tr>
    <tr><td class="paramname">sampled_borders</td><td>the borders points which are sampled </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>The list of obstacle and their points </td></tr>
    <tr><td class="paramname">obs_radius</td><td>Radius of each obstacle </td></tr>
    <tr><td class="paramname">obs_center</td><td>Center of each obstacle </td></tr>
    <tr><td class="paramname">config_folder</td><td>Config folder which contains config file to get parameters realted to RRT* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8f6c07df2df619bef2b28d6f7ebcac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::RRT_Star_ompl </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>localGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>sampled_borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>obs_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>obs_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classconfig__Params__planPath.html">config_Params_planPath</a>&#160;</td>
          <td class="paramname"><em>config_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implmentation of RRT Star function using OMPL library </p>
<p>This is an RRT Star using OMPL API's. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The robot location x </td></tr>
    <tr><td class="paramname">y</td><td>The robot location y </td></tr>
    <tr><td class="paramname">theta</td><td>The robot orientation theta </td></tr>
    <tr><td class="paramname">path</td><td>the output path variable </td></tr>
    <tr><td class="paramname">localGoals</td><td>the local goals which includes the victims and gate </td></tr>
    <tr><td class="paramname">borders</td><td>original borders </td></tr>
    <tr><td class="paramname">sampled_borders</td><td>the borders points which are sampled </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>The list of obstacle and their points </td></tr>
    <tr><td class="paramname">obs_radius</td><td>Radius of each obstacle </td></tr>
    <tr><td class="paramname">obs_center</td><td>Center of each obstacle </td></tr>
    <tr><td class="paramname">config_folder</td><td>Config folder which contains config file to get parameters realted to RRT* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf7520b9efd4309e03ec51e8cd7642b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> student::sample_borders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>borders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample the borders with multiple points. </p>
<p>interpolate the border points, to check if generated path is closer to sampled borders </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>border which is given as polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated border points </dd></dl>

</div>
</div>
<a class="anchor" id="a5ae5c8a6b753e8c2f86e2a6f70c44faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::sort_pair </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abf207b6433d914c39067b7d538c2956c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::sort_pair_mission2 </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, <a class="el" href="utils_8hpp.html#a18281038c49470960bd8f4d15b893441">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b8caf348979f55e58a75193233c219d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::unwarp </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image unwarping. </p>
<p>Image unwarping using opencv API warpPerspective() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>input image </td></tr>
    <tr><td class="paramname">img_out</td><td>output image </td></tr>
    <tr><td class="paramname">transf</td><td>tranformation matrix </td></tr>
    <tr><td class="paramname">config_folder</td><td>Output folder (if file existing then function justs reads the file to get rvec and tvec) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aba626c3c54f4003c9c06f7fea899efc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat student::debug_image</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a65fee22a07178fcde6362c2482b5fa7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat student::dist_coeffs_for_ex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
